%% mask2mesh
%
% -Purpose-
%   Converts a single binary image mask indicating the pixels belong to the
%   cells to cell meshes and models used in Oufti. This is essentially a
%   wrapper for the model2mesh() function. The models are generated by
%   finding the boundaries of the binary masks. Each model (Nx2) was then
%   converted to mesh (Nx4).
%
% -Input-
%   - mask (logical array): image mask indicating regions of cell pixels
%
% -Output-
%   - meshes (cell array): Nx4 mesh array for each cell
%   - models (cell array): Nx2 model array for each cell
%
% -Varargin-
%   - STEP_SIZE (numeric, double): default to 1.2, unclear, used in model2mesh()
%   - TOLERANCE (numeric, double): default to 1e-5, unclear, used in model2mesh()
%   - MESH_WIDTH (numeric, double): default to 500, unclear, used in model2mesh()
%
% -Dependency-:
%   1.  intxy2.m
%   2.  intxy2C.mex (compiled by intxy2C.c)
%   3.  intxyMulti.m
%   4.  intxyMultiC.mex (compiled by intxyMultiC.c)
%   5.  spsmooth.m
%   6.  model2mesh.m
%
% -Author-
%   Yingjie Xiang, 2019-01-17
%
% -Patch Notes-
%   2019-01-17: created the function


function [meshes,models,unique_bits] = mask2mesh(mask,varargin)

switch nargin
    case 1
        STEP_SIZE = 1.2;
        TOLERANCE = 1e-5;
        MESH_WIDTH = 500;
    case 2
        STEP_SIZE = varargin{1};
        TOLERANCE = 1e-5;
        MESH_WIDTH = 500;
    case 3
        STEP_SIZE = varargin{1};
        TOLERANCE = varargin{2};
        MESH_WIDTH = 500;
    case 4
        STEP_SIZE = varargin{1};
        TOLERANCE = varargin{2};
        MESH_WIDTH = varargin{3};
    otherwise
        error('Incorrect number of arguments.');
end

% ignore cells touching border
mask = imclearborder(mask,4);
% unique mask numbers sorted from smallest to largest
unique_bits = unique(mask(:));
models = cell(length(unique_bits)-1,1);
% 0 is backround remove this bit
unique_bits = unique_bits(unique_bits ~= 0);

% loops over unique mask IDs in ascending order
for ii = 1:length(unique_bits)
    % old version with center of pixels boundary
%     model = bwboundaries(mask == unique_bits(ii),8,'noholes');
%     models{ii} = model{1};

    % This approach includes the pixel area inside the polygon
    % extract pixel edge coordinates
    % take sides of pixels instead of center (similar to convexHull)
    [y,x] = find(mask == unique_bits(ii));
    dx = [0.0  0.0  0.5 -0.5];
    dy = [0.5 -0.5  0.0  0.0];
    x_edges = bsxfun(@plus, x, dx);
    y_edges = bsxfun(@plus, y, dy);
    x_edges = x_edges(:);
    y_edges = y_edges(:);
    
    warning('off')
    % use alphashape to approximate polygon
    shp = alphaShape(x_edges,y_edges);
    % smoothness of the outer edge
    shp.Alpha = 4;  
    % extract boundary coordinates with alpha 4 for smoothing
    [~, bf] = boundaryFacets(shp);
    
    % no smoothing boundary coordinates
    shp.Alpha = 1;  
    [~, bf_non] = boundaryFacets(shp);
    
    % distances of boundary coordinates from smoothed boundary
    [~,distance,~] = distance2curve([bf(:,1) bf(:,2)],[bf_non(:,1) bf_non(:,2)]);
    
    % find points that are more than 1 pixel away from smoothed boundary
    maskD = distance > 1;
    
    % include only smoothed boundaries and masked points to final boundary
    [~, inds] = inpolygon(bf_non(:,1),bf_non(:,2),[bf(:,1); bf_non(maskD,1)],[bf(:,2); bf_non(maskD,2)]); 
    bf_corr = bf_non(inds,:);
    
    % flip columns (x,y) and make a full loop of points
    models{ii} = [[bf_corr(:,2);bf_corr(1,2)], [bf_corr(:,1);bf_corr(1,1)]];
    warning('on')
end
% Remove any empty models
models(cellfun(@isempty,models)) = [];
% Swap the x,y, because of the way bwboundaries() works
models = cellfun(@(model) [model(:,2),model(:,1)],models,'UniformOutput',false);
% Generate mesh from model
meshes = cellfun(@(model) model2mesh(model,STEP_SIZE,TOLERANCE,MESH_WIDTH), models,'UniformOutput',false);

% Behavior of model2mesh() is not fully understandood. In some cases, the
% conversion from model (i.e. Nx2 cell contour) to mesh (i.e. Nx4 mesh)
% fail because of the non-optimal input parameters. The function catches
% the error and return the mesh as an integer '0'. Here, we remove these
% failed meshes and models.
% Remove failed meshes as well as the corresponding models
remove = cellfun(@(mesh) numel(mesh) == 1,meshes);
models(remove) = [];
meshes(remove) = [];
end