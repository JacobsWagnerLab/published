function [cellList] = Add_SeqA_Characteristics(cellList, path_to_images)
%{
-About-
Function to extract SeqA-mCherry signal information.
More specifically, the relative intracellular area of fluorescently
labeled SeqA and the position of the brightest SeqA-mCherry focus. 
The fields 'relative_seqA_area' and 'relative_seqA_spot_position' are added 
for each cell in the cellList.

-Inputs-
cellList:  cellList generated by Oufti, loaded into matlab. 
            
path:   full path to folder containing SeqA fluorescence images. This
        folder should contain a separate image for each frame included in
        the cellList
 
-varargin-
NA

-Outputs-
cellList:   updated cellList containing SeqA information, the fields 
            'relative_seqA_area' and 'relative_seqA_spot_position' are added 
            for each cell in the cellList.

-Example-
NA

-Supplementary-
NA

-Keywords-
SeqA, Relative SeqA area, Relative SeqA position, cellList, Oufti

-Dependencies-
filterIM (function that performs bandpass Gaussian filtering on an image)
loadimseries (function that loads in a series of individual images and
combines them into a stack)
findIrregularSpotsParallel (function that detects irregularly shaped SeqA
foci, see Arias-Cartin et al. (EMBO J, 2017) for details)

distancePointPolyline (from geom2D package)

This function requires functions from Matlab's image processing toolbox:
    graythresh.m
    imcrop.m
    poly2mask.m
    regionprops.m

-References-
NA

-Author-
Sander Govers, 10 November 2022
%}

%% Clean out cell entries in cellList that do not contain correct information

%Initiate counter to keep track of the number of removed cells
counter=0;

%Loop through frames and cells in the cellList
for ii=1:length(cellList.meshData)
    for jj=1:length(cellList.meshData{ii})
        %Remove empty entries, entries that do not contain cell mesh
        %information or very short entries
        if isempty(cellList.meshData{ii}{jj}) ||...
                ~isfield(cellList.meshData{ii}{jj},'mesh') ||...
                length(cellList.meshData{ii}{jj}.mesh)<=4
            cellList.meshData{ii}{jj}=[];
            %Add 1 to counter if cell entry is removed
            counter=counter+1;
        end
    end
end
%Display the total number of cell entries that was removed from the
%cellList
disp(['Number of cell entries cleaned out : ',num2str(counter)]);

%% Extract SeqA information

seqA_images = loadimseries(path_to_images);
%Display progress bar
w = waitbar(0,'Extracting SeqA information');

cellList = findIrregularSpotsParallel(cellList, seqA_images);


%Loop through frames included in the cellList
for ii = 1:length(cellList.meshData)
    %Select corresponding seqA image
    seqA_single_image = seqA_images(:,:,ii); 
    %Run filterIM function to enhance features in fluorescent image
    filtered_image = filterIM(seqA_single_image,'fq',1,'sl',10,'ithresh',0);
    %Loop through all cells in the frame
    for jj=1:length(cellList.meshData{ii})
        %Only do this for frames containing cells
        if ~isempty(cellList.meshData{ii}{jj})
            %Extract cell mesh and box region
            cell_mesh = cellList.meshData{ii}{jj}.mesh;
            cell_box=cellList.meshData{ii}{jj}.box;
            %Extract coordinates of cell outline
            outline_left = [cell_mesh(:,1);flipud(cell_mesh(:,3))];
            outline_right = [cell_mesh(:,2);flipud(cell_mesh(:,4))];
            %Define region of image to be cropped, corresponding to where
            %the cell is
            crop_region = [cell_box(1),cell_box(2),cell_box(3),cell_box(4)];
            %Crop original image so that only the small region containing the cell
            %remains
            cropped_image = imcrop(seqA_single_image, crop_region);
            %Crop filtered image so that only the small region containing the cell
            %remains
            filtered_cropped_image = imcrop(filtered_image, crop_region);
            %Normalize intensities in cropped filtered image
            filtered_cropped_image = (filtered_cropped_image-min(filtered_cropped_image(:)))./(max(filtered_cropped_image(:))-min(filtered_cropped_image(:)));
            %Define mask for image corresponding to the cell
            cell_mask = poly2mask(double(outline_left-crop_region(1)+1),double(outline_right-crop_region(2)+1),size(filtered_cropped_image,1),size(filtered_cropped_image,2));
            %Set all pixel values outside of the cell to 0 so they do not
            %interfere with the threshold calculation
            filtered_cropped_image(~cell_mask)=0;
            %Calculate threshold for resulting image
            [threshold,~] = graythresh(filtered_cropped_image(:));
            %Increase threshold size to include more of the SeqA signal
            threshold =1.5*threshold;
            %Initiate return black and white image (where 0 values correspond to undetected
            %signal and 1 to detected signal)
            bw_cropped_image = zeros(size(filtered_cropped_image,1),size(filtered_cropped_image,2));
            %Identify pixels that exceed threshold
            pixels_above_threshold = filtered_cropped_image>=threshold;
            %Set pixel that exceed the threshold to 1
            bw_cropped_image(pixels_above_threshold)=1;       
            %Set pixels that fall outside of the cell area to 0
            bw_cropped_image(~cell_mask)=0;  
            %use regionprops function to extract properties of SeqA and
            %the corresponding cell
            seqA_stats = regionprops(bw_cropped_image,cropped_image,'Area','PixelValues');
            cell_stats = regionprops(cell_mask,cropped_image,'Area','PixelValues');

            cellList.meshData{ii}{jj}.relative_seqA_area=[];
            %Only calculate the relative seqA area if the properties for
            %the seqA signal were extracted
            if ~isempty(seqA_stats)
                %Due to occassional issues (<0.1 %) with the regionprops function for these images,
                %use try statement to calculate the relative seqA area and
                %write it into the cellList
                try
                    cellList.meshData{ii}{jj}.relative_seqA_area=seqA_stats.Area/cell_stats.Area;
                %If calculation fails, set relative area to NaN
                catch
                    cellList.meshData{ii}{jj}.relative_seqA_area=NaN;
                end
            end
            
            %Only look at the position of the brightest SeqA focus if a
            %spot was indeed detected
            if isfield(cellList.meshData{ii}{jj}, 'spotPosition')
                %Extract coordinates of cell outline
                X_coordinates=double([cell_mesh(:,1) (cell_mesh(:,3))]);
                Y_coordinates=double([cell_mesh(:,2) (cell_mesh(:,4))]);
                model=horzcat(X_coordinates(:,1),Y_coordinates(:,1),X_coordinates(:,2),Y_coordinates(:,2));
                %Calculate centerline
                center_line = [(model(:,1)+model(:,3))/2 (model(:,2)+model(:,4))/2];
                %Find relative position of identified spots alond cell
                %length
                relative_position=[];
                for ss=1:size(cellList.meshData{ii}{jj}.spotPosition,1)
                    %distancePointPolyline comes from geom2D package
                    [~, tmp_pos] = distancePointPolyline(cellList.meshData{ii}{jj}.spotPosition(ss,:), center_line);
                    relative_position=[relative_position;tmp_pos];
                end
                %Find spot with highest intensity
                [~,idx_max_spot]=max(cellList.meshData{ii}{jj}.spotIntensity);
                %and store it in the cellList
                cellList.meshData{ii}{jj}.relative_seqA_spot_position=relative_position(idx_max_spot)/length(cell_mesh);
            end
        end
    end
    waitbar(ii/length(cellList.meshData));
end
close(w);
end
