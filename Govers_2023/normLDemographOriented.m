function [hdl, Ls, sigs]= normLDemographOriented(cellList,bNb,signal)

%--------------------------------------------------------------------------
%--------------------------------------------------------------------------
%function [hdl, Ls, sigs]= normLDemograph(cellList,bNb,signal)
%@author:  Manuel Campos
%@date:    August 09, 2016
%@copyright 2016-2017 Yale University
%==========================================================================
%**********output********:
%hdl:       handle to the final figure (demograph)
%Ls:        sorted list of cell lengthes (vector)
%sigs:      sorted list of normalized signals according to cell length
%           (matrix: nb of cells x bNb)
%**********Input********:
%cellList:	cellList as generated by Oufti, including signal.
%bNb:       number of bins for the signal along the cell length (integer)
%signal:	name of the signal to analyse (string - e.g. 'signal1')
%orient:    orientation of cells (tipN or ftsZ), determined using
%addTipNDataCC or addFtsZDataCC
%==========================================================================
%PURPOSE:
%       Generate a demograph with all signals normalized to the same length
%       range [0 1]. Signals are normalized by the volume under the signal
%       surface (normalized for cell area and total signal intensity).
%-------------------------------------------------------------------------- 
%-------------------------------------------------------------------------- 

dx=0.064;
L=zeros(1e6,2);
b = linspace(1/(2*bNb),1-1/(2*bNb),bNb);
sigs=zeros(1e6,length(b));

kk=1;
CL=cellList.meshData;
w = waitbar(0,'Collecting info');
for ii=1:length(CL)
    for jj=1:length(CL{ii})
        if ~isempty(CL{ii}{jj}) && isfield(CL{ii}{jj},'mesh') && length(CL{ii}{jj}.mesh)>4 && isfield(CL{ii}{jj},'signal1')
            mesh = CL{ii}{jj}.mesh;
            steplength = edist(mesh(2:end,1)+mesh(2:end,3),mesh(2:end,2)+mesh(2:end,4),...
                    mesh(1:end-1,1)+mesh(1:end-1,3),mesh(1:end-1,2)+mesh(1:end-1,4))/2;
            L(kk,:) = [sum(steplength)*dx, length(steplength)];
                       
            steparea = zeros(size(mesh,1)-1,1);
            for ll=1:size(mesh,1)-1
                steparea(ll)=polyarea([mesh(ll:ll+1,1);mesh(ll+1:-1:ll,3)],...
                    [mesh(ll:ll+1,2);mesh(ll+1:-1:ll,4)]);
            end
            try
            tmpS = (CL{ii}{jj}.(signal) + eps) ./ (steparea + eps);
            tmpS = (tmpS-min(tmpS))./(max(tmpS)-min(tmpS));
%Multiple ways to orient cells
            if sum(tmpS(1:round(length(tmpS)/2)))<sum(tmpS(round(length(tmpS)/2):end))
                tmpS = flipud(tmpS);
            end
%             if CL{ii}{jj}.tipNOrient == 0 
%                 tmpS = flipud(tmpS);
%             end
%             if CL{ii}{jj}.ftsZOrient == 0 
%                 tmpS = flipud(tmpS);
%             
            
            sigs(kk,:) = interp1([0;(1:length(tmpS))'./length(tmpS)],[0; tmpS],b);
            kk = kk+1;
            catch
                tmpS=[];
            end
        end
        waitbar(ii/length(CL)+ jj/(length(CL)*length(CL{ii})));
    end
end
close(w);

% Clean up the empty entries (everything beyond line kk-1 has not been
% filled and need to be deleted)
L=L(1:kk-1,:);
sigs = sigs(1:kk-1,:);

% Sort by cell length and sort signals according to this order
[~, ixL] = sort(L(:,1));
Ls = L(ixL,:);

hdl = figure;%hold on;
% subplot('position',[0.14 0.14 .75 .62]);
pcolor(sigs(ixL,:)');c=gray(100);colormap(c);shading flat
set(gca,'fontsize',8,'fontname','arial','layer','top','ydir','normal',...
    'xcolor','k','ycolor','k');
xlabel('Cell length percentile','fontsize',12,'fontweight','b','color','k');
ylabel('Relative cell length','fontsize',12,'fontweight','b','color','k');
set(gca,'ytick',[1, length(b)/2, length(b)],'yticklabel',{'0','0.5','1'});
set(gca,'xtick',[1, length(Ls)*0.25, length(Ls)*0.5, length(Ls)*0.75, length(Ls)],'xticklabel',{'0','25','50','75','100'});
hlg=colorbar;set(hlg,'fontsize',13,'fontname','arial','xcolor','k','ycolor','k');
ylabel(hlg,'Relative fluorescence intensity (a.u.)','fontsize',10,'fontweight','b','color','k');
% xt=get(gca,'xtick');xl=get(gca,'xlim');
% subplot('position',[0.14 0.8 .6310 .15]);
% plot(1:length(Ls),Ls(:,1),'-k');
% set(gca,'fontsize',16,'fontname','arial','xtick',xt,'xticklabel',{},...
%     'xlim',xl,'ylim',[min(Ls(:,1)) max(Ls(:,1))]);box off;
% ylabel('\it{L}','fontsize',16,'fontweight','b');

end

function d=edist(x1,y1,x2,y2)
    % complementary for "getextradata", computes the length between 2 points
    d=sqrt((x2-x1).^2+(y2-y1).^2);
end