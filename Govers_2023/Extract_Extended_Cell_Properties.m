function [cell_properties] = Extract_Extended_Cell_Properties(cellList,objects_name, varargin)
%{
-About-
Function to extract properties of individual cells from cellLists generated
by Oufti.

-Inputs-
cellList:  cellList generated by Oufti, loaded into matlab. 
            If SeqA and FtsZ information need to be added, run separate functions 
            (Add_SeqA_Characteristics or Add_FtsZ_Characteristics) first. The
            function will automatically look for this information.
objects_name:   name used to store information for detected objects (using
                Oufti's objectDetection module). Typically this is 'object'
                or 'nucleoiddata'. Enter 'none' in case no objects were
                detected
 
-varargin-
    'pixel_size':   pixel size, image resolution. If not specified, default
                    pixel size of 0.64 micron per pixel will be used

-Outputs-
cell_properties:    array in which each row corresponds to a cell and each
                    column to a different cellular property. The column
                    order is: 
                    1: frame
                    2: cell number
                    3: cell length (micron)
                    4: cell width (micron)
                    5: cell area (squared micron)
                    6: cell aspect ratio
                    7: cell volume (cubic micron)
                    8: surface area (squared micron)
                    9: surface area over volume (micron-1)
                    10: circularity
                    11: width variability
                    12: nucleoid length (micron)
                    13: nucleoid width (micron)
                    14: nucleoid area (squared micron)
                    15: nucleoid volume (cubic micron)
                    16: nc ratio
                    17: ftsZ-Venus amount (A.U.)
                    18: ftsZ-Venus concentration (A.U./squared micron)
                    19: seqA-mCherry amount (A.U.)
                    20: seqA-mCherry concentration (A.U./squared micron)
                    21: cell constriction (micron)
                    22: relative cell constriction position
                    23: nucleoid constriction (micron)
                    24: number of nucleoids
                    25: relative midcell FtsZ enrichment
                    26: relative FtsZ area
                    27: relative SeqA area
                    28: relative SeqA position


-Example-
NA

-Supplementary-
NA

-Keywords-
Cell properties, cell features, morphology, nucleoid, ftsZ, SeqA, cellList, Oufti

-Dependencies-
edist (function to calculate euclidean distance between points in 2D)


-References-
NA

-Author-
Sander Govers, 10 November 2022
%}

%% Parse varargin input
tic
%if pixel size is not specified, use default pixel size of 0.064
%micron per pixel.
pixel_size=0.064;

%Examine whether pixel size was specified using varargin input
for k = 1:length(varargin)
    if strcmpi(varargin{k}, 'pixel_size')
        %if pixel size is specified, use this to extract cellular
        %information
        pixel_size = varargin{k+1};
        %Check if specified pixel size is a single number, throw error if
        %this is not the case
        if length(pixel_size) ~= 1
            error('argument for pixel size was incorrectly formed')        
        end
    end
end

%% Clean out cell entries in cellList that do not contain correct information

%Initiate counter to keep track of the number of removed cells
counter=0;

%Loop through frames and cells in the cellList
for ii=1:length(cellList.meshData)
    for jj=1:length(cellList.meshData{ii})
        %Remove empty entries, entries that do not contain cell mesh
        %information or very short entries
        if isempty(cellList.meshData{ii}{jj}) ||...
                ~isfield(cellList.meshData{ii}{jj},'mesh') ||...
                length(cellList.meshData{ii}{jj}.mesh)<=4
            cellList.meshData{ii}{jj}=[];
            %Add 1 to counter if cell entry is removed
            counter=counter+1;
        end
    end
end
%Display the total number of cell entries that was removed from the
%cellList
disp(['Number of cell entries cleaned out : ',num2str(counter)]);


%% Extract properties from individual cells

w = waitbar(0,'Data coming soon...');

%Generate return structure
tab = struct('frame',[],'cell_id',[],'cell_length',[],'cell_width',[],'cell_area',[],...
    'cell_aspect_ratio',[],'cell_volume',[],'cell_surface_area',[],'cell_surface_area_over_volume',[],...
    'cell_circularity',[],'width_variability',[],'nucleoid_length',[],'nucleoid_width',[],...
    'nucleoid_area',[],'nucleoid_volume',[],'nc_ratio',[],'ftsZ_amount',[],'ftsZ_concentration',[],...
    'seqA_amount',[],'seqA_concentration',[],'cell_constriction',[],'cell_constriction_position',[],'nucleoid_constriction',[],...
    'nucleoid_number',[],'relative_mid_ftsZ_enrichment',[],'relative_ftsZ_area',[],...
    'relative_seqA_area',[],'relative_seqA_position',[]);

%Loop through frames and cells in the cellList and extract all features
for ii=1:length(cellList.meshData)
    clear mesh_data tmpCell tmp_structure
    %Only do this for frames containing cells
    if ~isempty(cellList.meshData{ii})      
        %for shorter notation
        mesh_data = cellList.meshData{ii};
        %Generate temporary structure to store data of current frame
        tmp_structure = struct('frame',[],'cell_id',[],'cell_length',[],'cell_width',[],'cell_area',[],...
    'cell_aspect_ratio',[],'cell_volume',[],'cell_surface_area',[],'cell_surface_area_over_volume',[],...
    'cell_circularity',[],'width_variability',[],'nucleoid_length',[],'nucleoid_width',[],...
    'nucleoid_area',[],'nucleoid_volume',[],'nc_ratio',[],'ftsZ_amount',[],'ftsZ_concentration',[],...
    'seqA_amount',[],'seqA_concentration',[],'cell_constriction',[],'cell_constriction_position',[],'nucleoid_constriction',[],...
    'nucleoid_number',[],'relative_mid_ftsZ_enrichment',[],'relative_ftsZ_area',[],...
    'relative_seqA_area',[],'relative_seqA_position',[]);
        %Loop through all cells in the current frame
        for jj=1:length(mesh_data)
            if ~isempty(mesh_data{jj})
                % Extract frame number and cell ids
                tmp_structure(jj).frame = ii;
                tmp_structure(jj).cell_id = cellList.cellId{ii}(jj);
            
                % Extract cell length from cell mesh information
                cell_mesh=double(mesh_data{jj}.mesh);

                %Calculate the distance between each cell segment
                step_length = edist(cell_mesh(2:end,1)+cell_mesh(2:end,3),cell_mesh(2:end,2)+cell_mesh(2:end,4),...
                    cell_mesh(1:end-1,1)+cell_mesh(1:end-1,3),cell_mesh(1:end-1,2)+cell_mesh(1:end-1,4))/2;
                %Use the sum of distances to calculate total cell length
                tmp_structure(jj).cell_length = sum(step_length)*pixel_size;

                % Cell width
                x1=cell_mesh(:,1);
                y1=cell_mesh(:,2);
                x2=cell_mesh(:,3);
                y2=cell_mesh(:,4);
                width = sort(sqrt((x1-x2).^2+(y1-y2).^2),'descend');
                width_not_ordered=sqrt((x1-x2).^2+(y1-y2).^2);
                %Calculate cell width based on the mean cell width of the
                %33% highest cell widths measured across the cell contour
                tmp_structure(jj).cell_width = mean(width(1:floor(length(width)/3)))*pixel_size;
                
                %Cell aspect ratio
                tmp_structure(jj).cell_aspect_ratio=tmp_structure(jj).cell_length/tmp_structure(jj).cell_width;

                % Cell area
                mesh_length = size(cell_mesh,1)-1;
                step_area=zeros(mesh_length,1);
                for counter=1:mesh_length
                    %Calculate the area of each cell segment
                    step_area(counter)=polyarea([cell_mesh(counter:counter+1,1);cell_mesh(counter+1:-1:counter,3)],...
                        [cell_mesh(counter:counter+1,2);cell_mesh(counter+1:-1:counter,4)]);
                end
                %Use the sum of areas to calculate total cell area
                tmp_structure(jj).cell_area = sum(step_area)*pixel_size*pixel_size;
                
                % Cell volume
                d = edist(cell_mesh(:,1),cell_mesh(:,2),cell_mesh(:,3),cell_mesh(:,4));
                %Calculate the volume of each cell segment
                step_volume = (d(1:end-1).*d(2:end) + (d(1:end-1)-d(2:end)).^2/3).*step_length*pi/4;
                %Use the sum of volumes to calculate total cell volume
                tmp_structure(jj).cell_volume = sum(step_volume)*pixel_size*pixel_size*pixel_size;
                
                % Surface area
                step_surface_area=zeros(length(cell_mesh)-1,1);
                for counter=1:length(cell_mesh)-1
                    %Calculate the surface area of each cell segment
                    step_surface_area(counter)=pdist2(cell_mesh(counter,1:2),cell_mesh(counter+1,1:2));
                end
                %Use the sum of surface area to calculate total cell
                %surface area
                tmp_structure(jj).cell_surface_area = sum(pi*step_surface_area.*(width_not_ordered(1:end-1)+width_not_ordered(2:end))./2)*pixel_size*pixel_size;
                
                % Surface area to volume ratio
                tmp_structure(jj).cell_surface_area_over_volume = tmp_structure(jj).cell_surface_area/tmp_structure(jj).cell_volume;
                
                % Cell circularity
                % First determine perimeter length
                a = [x1 y1;flipud([x2 y2])];
                b=a(1:end-1,:)-a(2:end,:);
                perim=bsxfun(@hypot,b(:,1),b(:,2));
                tmp_perim = sum(perim).*pixel_size;
                % and then calculate circularity
                tmp_structure(jj).cell_circularity=4*pi*tmp_structure(jj).cell_area/tmp_perim;
                
                % Cell width variability (calculated based on the 50%
                % highest cell widths of a cell)
                tmp_structure(jj).width_variability = std(width(1:floor(length(width)/2)))/mean(width(1:floor(length(width)/2)));
                
                % Cell constriction
                tmp_structure(jj).cell_constriction=NaN;
                tmp_structure(jj).cell_constriction_position=NaN;
                % In order to be able to run the constr[iction degree function
                mesh_data{jj}.lengthvector = cumsum(step_length)-step_length/2;
                mesh_data{jj}.length=sum(step_length);
                if isfield(mesh_data{jj},'signal0') && ~isempty(mesh_data{jj}.signal0)
                    [tmp_constr,tmp_structure(jj).cell_constriction_position,~] = ...
                         constDegreeSingleCell(mesh_data{jj},pixel_size);
                     tmp_structure(jj).cell_constriction = tmp_constr*2.5*tmp_structure(jj).cell_width;
                end
                                
                % Extract nucleoid chracteristics
                % Set default values to NaN, in case no nucleoid were
                % detected or nucleoid detection failed for a certain cell
                tmp_structure(jj).nucleoid_length = NaN;
                tmp_structure(jj).nucleoid_width = NaN;
                tmp_structure(jj).nucleoid_area = NaN;
                tmp_structure(jj).nucleoid_volume = NaN;
                tmp_structure(jj).nc_ratio = NaN;
                tmp_structure(jj).nucleoid_number= NaN;

                %Check if nucleoid information is present in cell
                %properties, this is done using the objects name specified
                %by the user in the input of the function
                if isfield(mesh_data{jj},objects_name)
                   tmp_nucleoid_length=[];
                   tmp_nucleoid_width=[];
                   tmp_nucleoid_area=[];
                   tmp_nucleoid_volume=[];
                   
                    if ~isempty(mesh_data{jj}.(objects_name).outlines)
                        %Identify number of detected nucleoids within a
                        %cell
                        tmp_structure(jj).nucleoid_number=length(mesh_data{jj}.(objects_name).outlines);
                        
                        %Loop through individual nucleoids within a cell and
                        %store their area
                        for piece=1:length(mesh_data{jj}.(objects_name).outlines)
                            tmp_nucleoid_area=[tmp_nucleoid_area;double(mesh_data{jj}.(objects_name).area{piece})];
                        end
                        %Sum area of all segments to extract nucleoid area
                        tmp_structure(jj).nucleoid_area = nansum(tmp_nucleoid_area)*pixel_size*pixel_size;
                        %Divide nucleoid area by the cell area to obtain the NC
                        %ratio
                        tmp_structure(jj).nc_ratio = tmp_structure(jj).nucleoid_area/tmp_structure(jj).cell_area;
                        
                        %Other nucleoid morphology variables
                        for piece=1:length(mesh_data{jj}.(objects_name).outlines)
                            %Nucleoid outlines have to be converted to mesh format to extract length, width, volume and
                            %absolute constriction
                            tmp_nucleoid_mesh=model2mesh(mesh_data{jj}.(objects_name).outlines{piece},1,0,50);
                            if  tmp_nucleoid_mesh~=0
                                %Nucleoid length
                                nucleoid_steplength = edist(tmp_nucleoid_mesh(2:end,1)+tmp_nucleoid_mesh(2:end,3),...
                                    tmp_nucleoid_mesh(2:end,2)+tmp_nucleoid_mesh(2:end,4),...
                                tmp_nucleoid_mesh(1:end-1,1)+tmp_nucleoid_mesh(1:end-1,3),...
                                tmp_nucleoid_mesh(1:end-1,2)+tmp_nucleoid_mesh(1:end-1,4))/2;
                                tmp_nucleoid_length = [tmp_nucleoid_length; sum(nucleoid_steplength)*pixel_size];
                                % Nucleoid width
                                x1_nucleoid=tmp_nucleoid_mesh(:,1);
                                y1_nucleoid=tmp_nucleoid_mesh(:,2);
                                x2_nucleoid=tmp_nucleoid_mesh(:,3);
                                y2_nucleoid=tmp_nucleoid_mesh(:,4);
                                tmp_nucleoid_width = [tmp_nucleoid_width;sqrt((x1_nucleoid-x2_nucleoid).^2+(y1_nucleoid-y2_nucleoid).^2)];
                                % Nucleoid volume
                                d = edist(tmp_nucleoid_mesh(:,1),tmp_nucleoid_mesh(:,2),...
                                    tmp_nucleoid_mesh(:,3),tmp_nucleoid_mesh(:,4));
                                nucleoid_stepvolume = (d(1:end-1).*d(2:end) + (d(1:end-1)-d(2:end)).^2/3).*nucleoid_steplength*pi/4;
                                tmp_nucleoid_volume = [tmp_nucleoid_volume;sum(nucleoid_stepvolume)*pixel_size*pixel_size*pixel_size];
                            else
                                tmp_nucleoid_length = [tmp_nucleoid_length;NaN];
                                tmp_nucleoid_width = [tmp_nucleoid_width;NaN];
                                tmp_nucleoid_volume = [tmp_nucleoid_volume;NaN];
                            end
                        end
                        %Calculate total nucleoid lengths, widths and
                        %volumes
                        if ~isempty(tmp_nucleoid_length)
                            nucleoid_total_length=sum(tmp_nucleoid_length);
                            nucleoid_widths_ordered = sort(tmp_nucleoid_width,'descend');
                            nucleoid_width = nanmean(nucleoid_widths_ordered(1:floor(length(nucleoid_widths_ordered)/3)))*pixel_size;
                            nucleoid_total_volume=sum(tmp_nucleoid_volume);
                        else
                            nucleoid_total_length=NaN;                
                            nucleoid_width = NaN;
                            nucleoid_total_volume=NaN;
                        end
                        %Write into structure
                        tmp_structure(jj).nucleoid_length=nucleoid_total_length;
                        tmp_structure(jj).nucleoid_width=nucleoid_width;
                        tmp_structure(jj).nucleoid_volume=nucleoid_total_volume;                                         
                    end
                end
                
                %Nucleoid constriction
                tmp_structure(jj).nucleoid_constriction=NaN;
                if isfield(mesh_data{jj},'signal1') && ~isempty(mesh_data{jj}.signal1) && sum(mesh_data{jj}.signal1)>0.1
                    [tmp_nucl_constr,~,~] = ...
                         constDegreeSingleNucleoid(mesh_data{jj},pixel_size);
                     tmp_structure(jj).nucleoid_constriction = tmp_nucl_constr*tmp_structure(jj).nucleoid_width;
                end
                                
                %FtsZ signal intensity
                tmp_structure(jj).ftsZ_amount=NaN;
                tmp_structure(jj).ftsZ_concentration=NaN;
                %Ensure FtsZ signal is stored in signal2
                if isfield(mesh_data{jj},'signal2')
                    tmp_structure(jj).ftsZ_amount=sum(mesh_data{jj}.signal2);
                    tmp_structure(jj).ftsZ_concentration=tmp_structure(jj).ftsZ_amount/tmp_structure(jj).cell_area;
                end
                                              
                %Midcell FtsZ enrichment
                tmp_structure(jj).relative_mid_ftsZ_enrichment=NaN;
                ix40=round(length(mesh_data{jj}.mesh)*0.40);
                ix60=round(length(mesh_data{jj}.mesh)*0.60);
                if isfield(mesh_data{jj},'signal2')
                     tmp_structure(jj).relative_mid_ftsZ_enrichment = sum(mesh_data{jj}.signal2(ix40:ix60))/...
                         sum(mesh_data{jj}.signal2);
                end
                
                %SeqA signal intensity
                tmp_structure(jj).seqA_amount=NaN;
                tmp_structure(jj).seqA_concentration=NaN;
                %Ensure SeqA signal is stored in signal3
                if isfield(mesh_data{jj},'signal3')
                    tmp_structure(jj).seqA_amount=sum(mesh_data{jj}.signal3);
                    tmp_structure(jj).seqA_concentration=tmp_structure(jj).seqA_amount/tmp_structure(jj).cell_area;
                end
                
                %Extract relative FtsZ area is this field is present in the
                %cellList
                tmp_structure(jj).relative_ftsZ_area=NaN;
                if isfield(mesh_data{jj},'relative_ftsZ_area')
                    tmp_structure(jj).relative_ftsZ_area=mesh_data{jj}.relative_ftsZ_area;
                end
                                
                %Extract relative SeqA area is this field is present in the
                %cellList
                tmp_structure(jj).relative_seqA_area=NaN;
                if isfield(mesh_data{jj},'relative_seqA_area')
                    tmp_structure(jj).relative_seqA_area=mesh_data{jj}.relative_seqA_area;
                end
                
                %Extract relative SeqA position
                tmp_structure(jj).relative_seqA_position=NaN;
                if isfield(mesh_data{jj},'relative_seqA_spot_position')
                    tmp_structure(jj).relative_seqA_position=mesh_data{jj}.relative_seqA_spot_position;
                end
            end
        end
        tab=[tab,tmp_structure];
    end
    
    waitbar(ii/length(cellList.meshData));

end
tab(1)=[];
toc
close(w);
clear ii jj kk steplength steparea stepvolume width d x1 x2 y1 y2 a b perDist
clear mBox imCell X Y contInt mesh lng w tmpStr piece perim Npixelvals
clear img imdb nucleoidarea nuCirc cell cellEntries mesh_data

%Convert structure to array
tmp_array(:,1)=cat(1,tab.frame);
tmp_array(:,2)=cat(1,tab.cell_id);
tmp_array(:,3)=cat(1,tab.cell_length);
tmp_array(:,4)=cat(1,tab.cell_width);
tmp_array(:,5)=cat(1,tab.cell_area);
tmp_array(:,6)=cat(1,tab.cell_aspect_ratio);
tmp_array(:,7)=cat(1,tab.cell_volume);
tmp_array(:,8)=cat(1,tab.cell_surface_area);
tmp_array(:,9)=cat(1,tab.cell_surface_area_over_volume);
tmp_array(:,10)=cat(1,tab.cell_circularity);
tmp_array(:,11)=cat(1,tab.width_variability);
tmp_array(:,12)=cat(1,tab.nucleoid_length);
tmp_array(:,13)=cat(1,tab.nucleoid_width);
tmp_array(:,14)=cat(1,tab.nucleoid_area);
tmp_array(:,15)=cat(1,tab.nucleoid_volume);
tmp_array(:,16)=cat(1,tab.nc_ratio);
tmp_array(:,17)=cat(1,tab.ftsZ_amount);
tmp_array(:,18)=cat(1,tab.ftsZ_concentration);
tmp_array(:,19)=cat(1,tab.seqA_amount);
tmp_array(:,20)=cat(1,tab.seqA_concentration);
tmp_array(:,21)=cat(1,tab.cell_constriction);
tmp_array(:,22)=cat(1,tab.cell_constriction_position);
tmp_array(:,23)=cat(1,tab.nucleoid_constriction);
tmp_array(:,24)=cat(1,tab.nucleoid_number);
tmp_array(:,25)=cat(1,tab.relative_mid_ftsZ_enrichment);
tmp_array(:,26)=cat(1,tab.relative_ftsZ_area);
tmp_array(:,27)=cat(1,tab.relative_seqA_area);
tmp_array(:,28)=cat(1,tab.relative_seqA_position);

%Write output array
cell_properties=tmp_array;

end

function d=edist(x1,y1,x2,y2)
%{
-About-
Function that caculates euclidean distance between 2 points

-Inputs-
x1: x-coordinate of first point
y1: y-coordinate of first point
x2: x-coordinate of second point
y2: y-coordinate of second point

-Author-
Sander Govers
%}    
    d=sqrt((x2-x1).^2+(y2-y1).^2);
end